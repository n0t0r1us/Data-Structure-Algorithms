#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;

int main() {
    int a1,b1,a2,b2,a3,b3;
    if (!(cin >> a1 >> b1)) return 0;
    cin >> a2 >> b2;
    cin >> a3 >> b3;
    int A[3], B[3];
    A[0]=a1; B[0]=b1;
    A[1]=a2; B[1]=b2;
    A[2]=a3; B[2]=b3;

    long long area = 0;
    for (int i=0;i<3;i++) area += (long long)A[i]*B[i];
    long long s = (long long)(sqrt((double)area) + 0.5);
    if (s*s != area) {
        cout << "NO\n";
        return 0;
    }
    int side = (int)s;

    int idx[3] = {0,1,2};
    bool ok = false;

    // iterate permutations
    do {
        // iterate orientations (2^3)
        for (int mask = 0; mask < 8 && !ok; ++mask) {
            int w[3], h[3];
            for (int i=0;i<3;i++) {
                int id = idx[i];
                if ( (mask >> i) & 1 ) { w[i] = B[id]; h[i] = A[id]; }
                else { w[i] = A[id]; h[i] = B[id]; }
            }

            // Case 1: all widths == side and heights sum to side (stack vertically)
            if (w[0]==side && w[1]==side && w[2]==side) {
                if (h[0]+h[1]+h[2] == side) { ok = true; break; }
            }
            // Case 2: all heights == side and widths sum to side (place horizontally)
            if (h[0]==side && h[1]==side && h[2]==side) {
                if (w[0]+w[1]+w[2] == side) { ok = true; break; }
            }

            // Case 3: first rectangle occupies full width (w0 == side), rest fill remaining height
            if (w[0] == side) {
                int remH = side - h[0];
                if (remH >= 0) {
                    // two possibilities to tile remaining rectangle (side x remH) with rectangles 1 and 2:
                    // - both widths == side and heights sum == remH (stack vertically)
                    if (w[1]==side && w[2]==side && h[1]+h[2]==remH) { ok = true; break; }
                    // - both heights == remH and widths sum == side (side by side)
                    if (h[1]==remH && h[2]==remH && w[1]+w[2]==side) { ok = true; break; }
                }
            }

            // Case 4: first rectangle occupies full height (h0 == side), rest fill remaining width
            if (h[0] == side) {
                int remW = side - w[0];
                if (remW >= 0) {
                    // tile remaining rectangle (remW x side) by rectangles 1 and 2:
                    // - both heights == side and widths sum == remW (side-by-side vertically aligned)
                    if (h[1]==side && h[2]==side && w[1]+w[2]==remW) { ok = true; break; }
                    // - both widths == remW and heights sum == side (stack vertically)
                    if (w[1]==remW && w[2]==remW && h[1]+h[2]==side) { ok = true; break; }
                }
            }
        }

    } while (next_permutation(idx, idx+3) && !ok);

    cout << (ok ? "YES\n" : "NO\n");
    return 0;
}
